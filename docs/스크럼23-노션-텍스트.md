# SCRUM-23: 메모리 스트림 + 리플렉션 + 프롬프트 분기 + A/B 테스트

## 개요

이번 스프린트에서는 에이전트 시뮬레이션의 현실성을 크게 향상시키기 위해 4가지 주요 기능을 구현했습니다. 각 기능은 에이전트의 행동 패턴을 더욱 자연스럽고 다양하게 만들어 실제 사용자 행동에 가깝게 모델링하는 것을 목표로 합니다.

**F4. 초기 위치 통계 반영**: 에이전트가 시뮬레이션을 시작하는 위치를 실제 유동인구 패턴에 맞게 조정했습니다. 이전에는 모든 에이전트가 망원동 영역 내에서 완전히 랜덤한 좌표에서 시작했지만, 이제는 역 근처, 시장 근처 등 실제로 사람들이 많이 모이는 지점을 고려하여 시작 위치를 결정합니다. 이 기능은 LLM 비용이 전혀 들지 않으며, 단순히 좌표 계산만 수행합니다.

**F3. 에이전트 메모리**: Stanford Generative Agents 스타일의 메모리 스트림과 리플렉션 메커니즘을 구현했습니다. 에이전트가 과거 방문 경험을 기억하고, 이를 바탕으로 다음 방문 결정에 영향을 받도록 했습니다. 이로 인해 매번 같은 매장에 방문하거나 만족도가 낮았던 곳을 재방문하는 비현실적인 패턴을 개선했습니다. 이 기능은 방문당 약 5분의 1 정도의 추가 LLM 비용이 발생합니다.

**F2. 프롬프트 분기**: 발견 경로 5종과 방문 목적 6종을 조합하여 총 30가지의 다양한 컨텍스트를 생성하고, 이를 프롬프트에 주입하도록 했습니다. 이를 통해 모든 에이전트가 동일한 정보 접근 경로와 방문 동기를 가정하던 문제를 해결했습니다. 이 기능은 기존 프롬프트를 확장하는 방식으로 구현되어 추가 LLM 비용이 발생하지 않습니다.

**F1. X리포트 A/B 비교**: X리포트(프로모션)의 효과를 정량적으로 측정할 수 있는 A/B 테스트 시스템을 구축했습니다. 동일한 시드로 리포트가 있는 경우와 없는 경우를 각각 실행하여 비교 분석할 수 있습니다. 이 기능은 2회 실행이 필요하므로 LLM 비용이 2배로 증가합니다.

---

## F4. 초기 위치 통계 반영

### 문제점

기존 시스템에서는 모든 에이전트가 망원동 영역 내에서 완전히 랜덤한 좌표에서 시뮬레이션을 시작했습니다. 이는 실제 유동인구 패턴을 전혀 반영하지 못하는 문제가 있었습니다. 예를 들어, 실제로는 역 근처나 시장 근처에서 사람들이 많이 모이지만, 기존 시스템에서는 이런 패턴을 고려하지 않았습니다.

### 해결 방법

SpawnPointSelector라는 새로운 컴포넌트를 만들어서, 12개의 주요 POI(관심 지점) 중에서 세그먼트별 가중치를 기반으로 시작 위치를 선택하도록 했습니다. 선택된 POI 위치에서 ±50미터 범위 내에서 가우시안 분포를 따르는 랜덤 지터를 적용하여 완전히 동일한 위치에서 시작하지 않도록 했습니다.

### 구현 세부사항

새로운 파일인 spawn_points.py를 생성하여 SpawnPOI 데이터 클래스와 MANGWON_POIS 리스트를 정의했습니다. 각 POI는 이름, 위도, 경도, 그리고 POI 타입(transit, market, residential, commercial)을 포함합니다.

망원역 1번출구, 망원역 2번출구, 합정역 1번출구, 합정역 7번출구, 망원시장 입구, 망원시장 중앙, 망원동 버스정류장 1, 망원동 버스정류장 2, 주거밀집 1 (망원1동), 주거밀집 2 (망원2동), 주거밀집 3 (합정동), 망리단길 입구 등 총 12개의 POI를 정의했습니다.

### 세그먼트별 POI 가중치

각 세그먼트별로 POI 타입에 대한 가중치를 다르게 설정했습니다. 예를 들어, 1인가구 세그먼트는 주거 지역에서 70% 확률로 시작하고, 시장에서 15%, 교통 지점에서 10%, 상업 지역에서 5% 확률로 시작합니다. 반면 데이트커플 세그먼트는 교통 지점에서 50%, 상업 지역에서 35% 확률로 시작하여 더 활동적인 패턴을 보입니다.

약속모임 세그먼트는 교통 지점에서 65% 확률로 시작하여 만남의 장소로 역이나 버스정류장을 선호하는 패턴을 반영합니다. 망원유입직장인은 교통 지점에서 55%, 상업 지역에서 30% 확률로 시작하며, 외부출퇴근직장인은 주거 지역에서 60% 확률로 시작하여 집 근처에서 출발하는 패턴을 보입니다.

### 수정된 파일

engine.py 파일에 _get_agent_spawn_location() 메서드를 추가하여 세그먼트 정보를 기반으로 적절한 스폰 위치를 선택하도록 했습니다. run_simulation.py 스크립트에서는 --archetype 모드에서 자동으로 SpawnPointSelector를 생성하고 연결하도록 수정했습니다.

---

## F3. 에이전트 메모리 (Memory Stream + Reflection)

### 문제점

기존 시스템에서는 에이전트가 과거 경험을 전혀 기억하지 못했습니다. 이로 인해 매번 같은 매장에 방문하거나, 만족도가 낮았던 곳을 재방문하는 비현실적인 패턴이 발생했습니다. 실제 사람들은 과거 경험을 바탕으로 다음 방문을 결정하는데, 이런 메커니즘이 없어서 시뮬레이션의 현실성이 떨어졌습니다.

### 해결 방법: Stanford Generative Agents 패턴 적용

Stanford 대학에서 개발한 Generative Agents 논문의 메모리 스트림과 리플렉션 패턴을 적용했습니다. 방문 이벤트가 발생하면 EventMemory에 저장하고, 다음 의사결정 시점에 관련된 메모리를 검색하여 프롬프트에 주입합니다. 또한 5회 방문마다 리플렉션을 트리거하여 선호도를 자동으로 조정합니다.

### 구현 세부사항

기존에 stub 형태로 존재하던 event_memory.py와 reflection.py 파일을 본격적으로 구현했습니다. EventMemory 클래스는 최대 200개의 메모리 엔트리를 저장할 수 있으며, 각 엔트리는 타임스탬프, 이벤트 타입, 설명, 중요도, 매장명, 카테고리, 만족도, 일자 등의 정보를 포함합니다.

이벤트 타입은 방문(visit), 리포트 수신(report_reception), 리플렉션(reflection) 등으로 구분됩니다. add_visit 메서드를 통해 방문 정보를 저장하고, add_report_reception 메서드를 통해 리포트 수신 정보를 저장합니다. retrieve_relevant 메서드는 쿼리 컨텍스트와 관련된 상위 k개의 메모리를 검색하여 반환합니다.

### 메모리 검색 스코어링 (Stanford GA 방식)

메모리 검색 시 세 가지 요소를 조합하여 점수를 계산합니다. 최근성(recency)은 40% 가중치를 가지며, 시간이 지날수록 지수적으로 감소합니다. 중요도(importance)는 30% 가중치를 가지며, 메모리 엔트리에 저장된 중요도 값을 그대로 사용합니다. 관련성(relevance)은 30% 가중치를 가지며, 카테고리, 매장명, 시간대 등의 키워드 매칭을 통해 계산됩니다.

최근성 계산은 경과 시간(시간 단위)에 -0.02를 곱한 값의 지수 함수를 사용하여, 시간이 지날수록 점수가 빠르게 감소하도록 했습니다. 관련성은 현재 쿼리와 메모리 내용의 유사도를 0.0부터 1.0 사이의 값으로 계산합니다.

### Reflection 메커니즘

5회 방문마다 리플렉션이 자동으로 트리거됩니다. 리플렉션은 규칙 기반 분석을 수행하여 에이전트의 선호도를 자동으로 조정합니다. 동일한 카테고리를 3회 이상 방문했고 만족도가 0.7 이상이면 해당 카테고리의 선호도를 0.1 증가시킵니다. 반대로 동일한 카테고리를 3회 이상 방문했지만 만족도가 0.4 미만이면 해당 카테고리의 선호도를 0.1 감소시킵니다.

동일한 매장을 3회 이상 방문하면 단골 패턴으로 감지하고, 5회 이상 방문하면서 4개 이상의 고유 카테고리를 경험하면 다양성을 추구하는 패턴으로 감지합니다.

### 프롬프트 통합

메모리 컨텍스트는 프롬프트에 자연어 형태로 주입됩니다. 예를 들어, "3일 전 망원시장손칼국수 방문 (만족도: 높음) - 칼국수 맛있었음", "5일 전 몬스터스토리지 방문 (만족도: 보통) - 디저트 괜찮았지만 가격이...", "반영: 한식 카테고리 선호도 증가 (최근 만족도 높음)" 등의 형태로 표시됩니다.

### 크로스데이 지속성

메모리와 리플렉션 결과는 날짜가 바뀌어도 유지됩니다. reset_daily_states() 메서드는 하루의 식사 횟수만 리셋하고, 메모리와 리플렉션은 그대로 유지합니다. _day_number를 증가시켜 시간 감쇠 계산의 정확도를 유지합니다.

### 출력 파일

전체 에이전트의 메모리와 리플렉션 결과를 agent_memories.json 파일에 직렬화하여 저장합니다. 이를 통해 시뮬레이션 후 각 에이전트가 어떤 경험을 했는지, 어떤 선호도 변화가 있었는지 분석할 수 있습니다.

---

## F2. 프롬프트 분기 (발견 경로 × 방문 목적)

### 문제점

기존 시스템에서는 모든 에이전트가 동일한 정보 접근 경로와 방문 동기를 가정했습니다. 이로 인해 매장 선택 기준이 단일하고, 모든 에이전트가 비슷한 방식으로 의사결정을 내리는 문제가 있었습니다. 실제로는 사람마다 정보를 얻는 방법이 다르고, 방문 목적도 다양합니다.

### 해결 방법: 2축 컨텍스트 분기

세그먼트, 생활양식, 시간대를 기반으로 발견 경로 5종과 방문 목적 6종을 조합하여 총 30가지의 다양한 컨텍스트를 생성합니다. 이 컨텍스트는 자연어로 변환되어 Step 2(카테고리 선택)와 Step 3(매장 선택) 프롬프트에 주입됩니다.

### 구현 세부사항

새로운 파일인 discovery_context.py를 생성하여 DiscoveryContext 클래스를 구현했습니다. 이 클래스는 에이전트의 세그먼트, 생활양식, 시간대, 배고픔 수준 등을 기반으로 적절한 발견 경로와 방문 목적을 선택합니다.

### 발견 경로 5종

네이버검색 경로는 블로그 리뷰를 기반으로 탐색하는 방식으로, 리뷰 수와 평점이 높은 매장을 우선적으로 선택합니다. 카카오지도 경로는 지도 앱을 기반으로 탐색하는 방식으로, 가까운 거리와 영업 중인 매장을 우선적으로 선택합니다.

길거리발견 경로는 도보 중 우연히 발견하는 방식으로, 외관, 줄, 냄새 등에 영향을 받습니다. SNS추천 경로는 인스타그램이나 틱톡 등을 통해 정보를 얻는 방식으로, 인스타그래머블하거나 트렌디한 매장을 우선적으로 선택합니다. 지인추천 경로는 친구나 가족으로부터 추천받는 방식으로, 추천받은 특정 매장을 우선적으로 선택합니다.

### 방문 목적 6종

맛집탐방 목적은 변화추구와 미식탐구 성향이 높을 때 트리거되며, 맛 평점을 최우선으로 고려하고 새로운 곳을 선호합니다. 회식 목적은 약속모임 세그먼트와 친구나 동료와 함께 있을 때 트리거되며, 단체석, 술 메뉴, 다양한 메뉴를 고려합니다.

혼밥 목적은 1인가구 세그먼트가 혼자 있을 때 트리거되며, 1인석과 빠른 서비스를 고려합니다. 데이트 목적은 데이트커플 세그먼트가 연인과 함께 있을 때 트리거되며, 분위기와 서비스를 중시합니다.

간편식사 목적은 직장인 세그먼트가 점심 시간에 트리거되며, 빠르고 가까운 곳을 선호합니다. 카페/디저트 목적은 야간 시간대에 배고픔이 낮을 때 트리거되며, 분위기와 디저트 메뉴를 고려합니다.

### 가중치 할당

생활양식에 따라 발견 경로의 가중치가 달라집니다. 변화추구 성향이 높은 에이전트는 네이버검색 30%, SNS추천 25%, 카카오지도 20%, 길거리발견 15%, 지인추천 10%의 확률을 가집니다. 반대로 단조로운패턴 성향이 높은 에이전트는 길거리발견 40%, 지인추천 20%, 네이버검색 15%, 카카오지도 15%, SNS추천 10%의 확률을 가집니다.

### 수정된 파일

chained_decide.py 파일의 Step 2와 Step 3에 discovery_context를 주입하도록 수정했습니다. models.py 파일의 SimulationEvent 클래스에 discovery_channel과 visit_purpose 필드를 추가했습니다. engine.py 파일의 이벤트 로깅 부분에 새로운 필드를 반영했습니다.

프롬프트 템플릿 파일인 category_selection.txt와 store_selection.txt에 {discovery_context} 섹션을 추가했습니다. store_selection.txt에는 발견 경로와 방문 목적에 따른 선택 기준도 추가했습니다.

---

## F1. X리포트 A/B 비교

### 문제점

X리포트(프로모션)의 효과를 정량적으로 측정할 방법이 없었습니다. 리포트가 실제로 에이전트의 방문 패턴에 영향을 미치는지, 얼마나 영향을 미치는지 알 수 없었습니다.

### 해결 방법: 동일 시드 2회 실행 비교

동일한 시드 값을 사용하여 리포트가 있는 경우(Run A)와 없는 경우(Run B)를 각각 실행합니다. 두 실행 결과를 비교하여 리포트의 효과를 정량적으로 분석합니다. 비교 결과는 ab_comparison.json 파일과 ab_comparison_summary.md 파일로 저장됩니다.

### 구현 세부사항

새로운 파일인 ab_comparison.py를 생성하여 ABComparator 클래스를 구현했습니다. 이 클래스는 두 시뮬레이션 결과 데이터프레임을 받아서 24개의 지표를 계산하고 비교합니다.

### ComparisonMetrics (24개 지표)

전체 전환율 카테고리에는 A/B 그룹의 전환율, 델타 값, 백분율 변화가 포함됩니다. 방문수 카테고리에는 A/B 그룹의 총 방문수와 방문수 차이가 포함됩니다. 카테고리 분포 카테고리에는 A/B 그룹의 카테고리별 방문 분포와 분포 차이가 포함됩니다.

리포트 대상 매장 카테고리에는 A/B 그룹에서 리포트 대상 매장에 대한 방문수와 방문수 차이가 포함됩니다. 세그먼트별 전환율 카테고리에는 각 세그먼트별 A/B 그룹의 전환율과 전환율 차이가 포함됩니다.

정보 확산 카테고리에는 리포트 수신율과 리포트에 영향을 받아 실제로 방문한 비율이 포함됩니다. 시간대별 방문 카테고리에는 각 시간대별 A/B 그룹의 방문수가 포함됩니다. 발견 경로 카테고리에는 각 발견 경로별 A/B 그룹의 방문수가 포함됩니다.

### 에이전트별 리포트 수신 확률 차등화

모든 에이전트가 동일한 확률로 리포트를 수신하는 것이 아니라, 에이전트의 특성에 따라 차등화했습니다. 기본 확률은 0.3으로 설정하고, 생활양식에 따라 보정합니다. 변화추구 성향이 높으면 1.5배, 단조로운패턴 성향이 높으면 0.7배를 적용합니다.

트렌드 민감도에 따라서도 보정합니다. 트렌드 민감도에 0.6을 곱하고 0.7을 더하여 0.7부터 1.3 사이의 값을 만듭니다. 최종 확률은 0.9를 넘지 않도록 제한합니다.

### CLI 사용법

A/B 테스트를 실행하려면 --ab-test 플래그와 --seed 플래그를 함께 사용합니다. 예를 들어, python scripts/run_simulation.py --archetype --chained --ab-test --seed 42 명령어를 실행하면 시드 42로 리포트가 있는 경우와 없는 경우를 각각 실행하고 비교합니다.

리포트 없이 단독 실행하려면 --no-reports 플래그를 사용합니다. 시드를 지정하여 단독 실행하려면 --seed 플래그에 원하는 시드 값을 지정합니다.

### 수정된 파일

engine.py 파일에 _get_report_reception_prob() 메서드를 추가하여 에이전트별 리포트 수신 확률을 계산하도록 했습니다. run_simulation.py 스크립트에 --no-reports, --ab-test, --seed 플래그를 추가하고 _run_ab_test() 함수를 구현했습니다. dashboard.py 스크립트에 A/B 비교 시각화 섹션을 추가했습니다.

### 대시보드 A/B 비교 섹션

전환율 메트릭 3열 차트는 A/B 그룹의 전환율과 변화율을 표시합니다. 정보 확산 차트는 리포트 수신율과 영향 전환율을 표시합니다. 리포트 대상 매장 바 차트는 각 매장별로 A 그룹과 B 그룹의 방문수를 비교합니다.

세그먼트별 전환율 차트는 각 세그먼트 그룹별로 A 그룹과 B 그룹의 전환율을 비교합니다. 카테고리 분포 차트는 전체 카테고리에서 A 그룹과 B 그룹의 방문 분포를 비교합니다. 발견 경로 비교 차트는 각 발견 경로 채널별로 A 그룹과 B 그룹의 방문수를 비교합니다.

---

## 전체 아키텍처 흐름

시뮬레이션은 run_simulation.py CLI 스크립트를 통해 시작됩니다. --archetype, --chained, --ab-test, --seed 등의 플래그를 사용하여 실행 모드를 지정합니다.

첫 번째 단계로 stores.csv 파일을 읽어서 Environment(StreetNetwork)를 생성합니다. 두 번째 단계로 ArchetypeGenerator를 사용하여 64명의 에이전트를 생성합니다. 세 번째 단계로 SpawnPointSelector를 사용하여 각 에이전트의 세그먼트에 맞는 POI 위치를 선택합니다.

네 번째 단계로 SimulationEngine.run_simulation() 메서드를 실행합니다. 이 메서드는 각 에이전트에 대해 각 타임스텝마다 다음 프로세스를 반복합니다.

먼저 리포트 수신을 처리합니다. 에이전트별 차등 확률에 따라 리포트를 수신할 수 있습니다. 다음으로 Step 1에서 시간대 의사결정을 수행합니다. 이는 Smart 규칙 기반으로 처리됩니다.

그 다음 Memory.retrieve_relevant() 메서드를 호출하여 관련된 메모리 컨텍스트를 가져옵니다. 동시에 DiscoveryContext를 생성하여 발견 경로와 방문 목적을 기반으로 한 컨텍스트 텍스트를 만듭니다.

Step 2에서는 카테고리 선택을 수행합니다. LLM을 사용하되, 메모리 컨텍스트와 발견 경로 컨텍스트를 프롬프트에 주입합니다. Step 3에서는 매장 선택을 수행합니다. LLM을 사용하되, 리뷰 정보, 메모리 컨텍스트, 발견 경로 컨텍스트를 모두 프롬프트에 주입합니다.

방문이 완료되면 Memory.add_visit() 메서드를 호출하여 방문 정보를 메모리에 저장합니다. 그 다음 리플렉션 체크를 수행하여 5회 방문마다 리플렉션을 트리거합니다.

다섯 번째 단계로 시뮬레이션 결과를 CSV 파일과 agent_memories.json 파일로 저장합니다. A/B 테스트 모드인 경우, 여섯 번째 단계로 ABComparator를 사용하여 두 실행 결과를 비교하고 ab_comparison.json 파일을 생성합니다.

대시보드는 dashboard.py Streamlit 스크립트를 통해 실행됩니다. 지도 시각화, 시간대별 분석, 카테고리별 분석, 프로필 분석 등을 제공합니다. 발견 경로와 방문 목적의 조합을 히트맵으로 표시합니다. A/B 비교 모드인 경우 ab_comparison.json 파일을 로드하여 A/B 비교 분석 섹션을 표시합니다.

---

## 변경 파일 목록

### 신규 생성 파일 (4개)

spawn_points.py 파일은 F4 기능을 구현한 파일로, POI 기반 스폰 포인트 선택기를 포함합니다. discovery_context.py 파일은 F2 기능을 구현한 파일로, 발견 경로와 방문 목적 컨텍스트를 생성합니다. ab_comparison.py 파일은 F1 기능을 구현한 파일로, A/B 비교 메트릭과 분석기를 포함합니다. SCRUM-23-memory-stream-reflect.md 파일은 이번 스프린트의 전체 문서입니다.

### 확장된 파일 (기존 stub → 본격 구현, 2개)

event_memory.py 파일은 F3 기능을 구현한 파일로, Memory Stream을 본격적으로 구현했습니다. reflection.py 파일은 F3 기능을 구현한 파일로, Reflection 메커니즘을 본격적으로 구현했습니다.

### 수정된 파일 (5개)

engine.py 파일은 F4, F3, F2, F1 기능 모두에 관련된 수정이 있었습니다. spawn_selector를 추가하고, current_time을 전달하며, 리포트 수신 확률을 차등화하고, discovery 필드를 추가했습니다.

chained_decide.py 파일은 F3, F2 기능에 관련된 수정이 있었습니다. 메모리를 통합하고, 발견경로 컨텍스트를 주입하며, reflection 트리거를 추가했습니다.

models.py 파일은 F2 기능에 관련된 수정이 있었습니다. SimulationEvent 클래스에 discovery_channel과 visit_purpose 필드를 추가했습니다.

run_simulation.py 파일은 F4, F3, F1 기능에 관련된 수정이 있었습니다. spawn_selector를 추가하고, 메모리를 저장하며, A/B 테스트 모드를 구현했습니다.

dashboard.py 파일은 F2, F1 기능에 관련된 수정이 있었습니다. 발견경로와 방문 목적 차트를 추가하고, A/B 비교 섹션을 추가했습니다.

### 수정된 프롬프트 템플릿 (2개)

category_selection.txt 파일은 F3, F2 기능에 관련된 수정이 있었습니다. {memory_context}와 {discovery_context} 섹션을 추가했습니다.

store_selection.txt 파일은 F3, F2 기능에 관련된 수정이 있었습니다. {memory_context}와 {discovery_context} 섹션을 추가하고, 발견 경로와 방문 목적에 따른 선택 기준을 추가했습니다.

---

## 하위 호환성

모든 새로운 CLI 플래그는 opt-in 방식으로 구현되어 있어, 기존의 --archetype --chained 동작은 변경되지 않습니다. SimulationEvent의 새로운 필드는 Optional[str] = None으로 설정되어 있어, 기존 코드와의 호환성을 유지합니다.

프롬프트의 새로운 변수는 DecideModule에서 빈 문자열을 전달하도록 구현되어 있어, 메모리나 발견 경로 기능이 없는 경우에도 정상적으로 작동합니다. 메모리와 리플렉션 기능은 ChainedDecideModule에서만 활성화되므로, 다른 의사결정 모듈에는 영향을 주지 않습니다.

SpawnPointSelector는 archetype 모드에서만 생성되므로, 기존 모드에서는 여전히 랜덤 좌표를 사용합니다. 이러한 설계를 통해 기존 기능의 안정성을 유지하면서 새로운 기능을 점진적으로 도입할 수 있습니다.
