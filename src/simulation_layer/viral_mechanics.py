"""
Viral mechanics: Influencer visits generate word-of-mouth events
that spread to other agents' memories.
"""

import random
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional

from src.simulation_layer.persona.agent_persona import AgentPersona
from src.simulation_layer.persona.memory_structures.event_memory import EventMemory


@dataclass
class ViralEvent:
    """A viral event generated by an influencer visit."""
    source_agent_id: int
    source_agent_name: str
    store_name: str
    category: str
    satisfaction: float
    influence_score: float
    timestamp: datetime


class ViralEngine:
    """Processes influencer visits and generates viral spread events."""

    VIRAL_THRESHOLD = 0.3       # Minimum influence_score to trigger viral
    SATISFACTION_THRESHOLD = 0.6  # Minimum satisfaction for positive viral
    SPREAD_BASE_PROB = 0.15      # Base probability per target agent

    def __init__(self):
        # Store influence bonuses from recent viral events
        self._store_bonuses: Dict[str, float] = {}
        # Track viral events for logging
        self._recent_viral: List[ViralEvent] = []

    def process_visits(
        self,
        visit_events: List[dict],
        agents: List[AgentPersona],
    ) -> List[ViralEvent]:
        """Extract viral events from this timeslot's visits.

        Args:
            visit_events: List of dicts with keys:
                agent_id, store_name, category, satisfaction, influence_score
            agents: All agents for reference
        """
        viral_events = []

        for event in visit_events:
            influence = event.get("influence_score", 0.0)
            satisfaction = event.get("satisfaction", 0.5)

            if influence < self.VIRAL_THRESHOLD:
                continue
            if satisfaction < self.SATISFACTION_THRESHOLD:
                continue

            ve = ViralEvent(
                source_agent_id=event["agent_id"],
                source_agent_name=event.get("agent_name", ""),
                store_name=event["store_name"],
                category=event.get("category", ""),
                satisfaction=satisfaction,
                influence_score=influence,
                timestamp=event.get("timestamp", datetime.now()),
            )
            viral_events.append(ve)

            # Update store bonus
            bonus = min(0.2, influence * satisfaction * 0.3)
            current = self._store_bonuses.get(ve.store_name, 0.0)
            self._store_bonuses[ve.store_name] = min(0.3, current + bonus)

        self._recent_viral.extend(viral_events)
        return viral_events

    def apply_viral_to_agents(
        self,
        viral_events: List[ViralEvent],
        agent_memories: Dict[int, EventMemory],
        agents: List[AgentPersona],
        current_time: datetime,
    ) -> int:
        """Inject viral events into target agents' memories.

        Returns number of agents who received viral info.
        """
        if not viral_events:
            return 0

        spread_count = 0

        for ve in viral_events:
            for agent in agents:
                # Don't spread to self
                if agent.id == ve.source_agent_id:
                    continue

                # Spread probability based on:
                # - Base prob
                # - Target's trend_sensitivity (higher = more receptive)
                # - Source's influence_score
                prob = (
                    self.SPREAD_BASE_PROB
                    * ve.influence_score
                    * (0.5 + agent.trend_sensitivity * 0.5)
                )

                # Same segment bonus
                if (hasattr(agent, '_archetype') and agent._archetype
                    and hasattr(ve, '_source_segment')):
                    pass  # Optional: same segment gets higher prob

                if random.random() < prob:
                    memory = agent_memories.get(agent.id)
                    if memory is None:
                        continue

                    # Add as recommendation memory
                    sat_text = "강추" if ve.satisfaction >= 0.8 else "추천"
                    content = (
                        f"{current_time.strftime('%m/%d')} "
                        f"SNS/지인 추천: {ve.source_agent_name}님이 "
                        f"{ve.store_name}({ve.category}) {sat_text}. "
                        f"영향력 있는 리뷰어의 후기."
                    )
                    from src.simulation_layer.persona.memory_structures.event_memory import MemoryEntry
                    entry = MemoryEntry(
                        timestamp=current_time,
                        event_type="viral_recommendation",
                        content=content,
                        importance=0.5 + ve.influence_score * 0.3,
                        store_name=ve.store_name,
                        category=ve.category,
                        satisfaction=ve.satisfaction,
                        metadata={
                            "source": ve.source_agent_name,
                            "influence_score": ve.influence_score,
                        },
                    )
                    memory.add(entry, current_time)
                    spread_count += 1

        return spread_count

    def get_store_influence_bonus(self, store_name: str) -> float:
        """Get accumulated influence bonus for a store.

        Used to boost store's preference score in selection.
        Decays each timeslot.
        """
        return self._store_bonuses.get(store_name, 0.0)

    def decay_bonuses(self) -> None:
        """Decay store bonuses over time (call each timeslot)."""
        to_remove = []
        for store, bonus in self._store_bonuses.items():
            new_bonus = bonus * 0.7  # 30% decay per timeslot
            if new_bonus < 0.01:
                to_remove.append(store)
            else:
                self._store_bonuses[store] = new_bonus
        for store in to_remove:
            del self._store_bonuses[store]

    def get_recent_viral_count(self) -> int:
        return len(self._recent_viral)

    def clear_recent(self) -> None:
        self._recent_viral.clear()
